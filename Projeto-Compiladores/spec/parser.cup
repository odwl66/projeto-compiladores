import compiler.util.*;

parser code  {:
 public void report_error(String message, Object info){
   StringBuffer m = new StringBuffer("Error: " + message + "\n");
   System.err.print(m);
 }

 public void report_fatal_error(String message, Object info) {
   report_error(message, info);
   throw new RuntimeException("Fatal Syntax Error");
 }
:};

terminal COMMA, SEMICOLON, COLON, DOT, DOT_DOT, LPAREN, RPAREN, LBRACK, RBRACK, POINTER;
terminal EQ, SIGN;
terminal PROGRAM, CONST, LABEL, TYPE, PACKED, ARRAY, OF, RECORD, BEGIN, END, CASE, SET, FILE, VAR, PROCEDURE;
terminal IF, ELSE, DO, WHILE, FOR, BREAK, CONTINUE, RETURN, GOTO, UNTIL, REPEAT;

terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING;
terminal java.lang.Number INTEGER_NUMBER;
terminal java.lang.Number REAL_NUMBER;

non terminal program;
non terminal program_heading, program_heading_opt, block;
non terminal identifier_list;
non terminal declaration_part, statement_part, statement_sequence, simple_statement, structured_statement;
non terminal statement, assignment_statement, procedure_statement, goto_statement;
non terminal expression, expression_opt, expression_end_option, expression_loop;
non terminal while_statement, repeat_statement, for_statement, initial_expression, final_expression;
non terminal if_statement, case_statement, case_limb;
non terminal actual_parameter_list, actual_parameter, actual_value, actual_procedure, actual_function;
non terminal actual_variable, record_variable, procedure_identifier, function_identifier;
non terminal compound_statement, repetitive_statement, conditional_statement, with_statement;
non terminal label, label_declaration_part, label_declaration_part_opt, label_declaration_part_ext;
non terminal constant_definition_part, constant_definition_part_opt, constant_definition_part_ext, constant_definition, constant;
non terminal simple_type, structured_type, pointer_type, type_identifier, type;
non terminal type_definition_part, type_definition_part_opt, type_definition_part_ext, type_definition;
non terminal subrange_type, enumerated_type;
non terminal unpacked_structured_type, array_type, record_type, set_type, file_type;
non terminal index_type, index_type_ext, element_type, field_list;
non terminal fixed_part, variant_part_opt, variant_part;
non terminal record_section, record_section_ext;
non terminal tag_field;
non terminal variant, variant_ext;
non terminal case_label_list;
non terminal constant_ext;
non terminal lower_bound, upper_bound;
non terminal variable_declaration_part, variable_declaration_part_opt, variable_declaration_part_ext, variable_declaration;
non terminal procedure_and_function_declaration_part, procedure_and_function_declaration_part_opt;
non terminal procedure_declaration, procedure_heading, procedure_body, directive, procedure_identification;
non terminal formal_parameter_list_opt, formal_parameter_list, formal_parameter_section, formal_parameter_section_ext;
non terminal value_parameter_section, variable_parameter_section, procedure_parameter_section, function_parameter_section;
non terminal parameter_type, conformant_array_schema, packed_conformant_array_schema, unpacked_conformant_array_schema;
non terminal bound_specification, bound_specification_ext, ordinal_type_identifier;
non terminal function_declaration;
non terminal number;
non terminal base_type;
non terminal file_component_type;


start with program;

program ::=
    program_heading block DOT {:Logger.print("Program definition");:}
;

program_heading ::=
    PROGRAM IDENTIFIER program_heading_opt SEMICOLON {:Logger.print("Program header definition");:}
;

program_heading_opt ::=
	|
	LPAREN identifier_list RPAREN {:Logger.print("Program header optional definition");:}
;

identifier_list ::= 
	IDENTIFIER COMMA identifier_list {:Logger.print("Identifier list definition");:}
	| IDENTIFIER:id   {:Logger.print("Identifier list definition, id: " + id);:}
;

block ::= 
	declaration_part statement_part {: Logger.print("Block definition");:}
;

declaration_part ::=
	label_declaration_part_opt 
	constant_definition_part_opt
	type_definition_part_opt
	variable_declaration_part_opt
	procedure_and_function_declaration_part_opt	{: Logger.print("Declaration part definition");:}
;

label_declaration_part_opt ::= 
	|
	label_declaration_part {: Logger.print("Label declaration part optional definition");:}
;

label_declaration_part ::=
	LABEL label label_declaration_part_ext SEMICOLON {: Logger.print("Label declaration part definition");:}
;

label_declaration_part_ext ::=
	|
	COMMA label label_declaration_part_ext  {: Logger.print("Label declaration part extended definition");:}
;

label ::=
	INTEGER_NUMBER:in {: Logger.print("Label definition: " + in);:}
;

constant_definition_part_opt  ::=
	|
	constant_definition_part {: Logger.print("Constant definition part optional definition");:}
;

constant_definition_part ::=
	CONST constant_definition SEMICOLON constant_definition_part_ext {: Logger.print("Constant definition part definition");:}
;

constant_definition_part_ext ::=
	|
	constant_definition SEMICOLON constant_definition_part_ext {: Logger.print("Constant definition part extended definition");:}
;

constant_definition ::=
	IDENTIFIER:id EQ constant:c {: Logger.print("Constant definition definition, id: " + id + " constant:" + c);:}
;

constant ::=
	IDENTIFIER:id {: Logger.print("Constant definition, id: " + id);:}
	| SIGN IDENTIFIER:id {: Logger.print("Constant definition, id: " + id);:}
	| number:n {: Logger.print("Constant definition, number: " + n);:}
	| STRING:s {: Logger.print("Constant definition, string: " + s);:}
;

number ::=
	INTEGER_NUMBER {: Logger.print("Number definition");:}
	| REAL_NUMBER {: Logger.print("Number definition");:}
;

type_definition_part_opt ::=
	|
	type_definition_part {: Logger.print("Type definition part optional definition");:}
;

type_definition_part ::=
	TYPE type_definition SEMICOLON type_definition_part_ext {: Logger.print("Type definition part definition");:}
;

type_definition_part_ext ::=
	|
	type_definition SEMICOLON type_definition_part_ext {: Logger.print("Type definition part extended definition");:}
;

type_definition ::=
	IDENTIFIER:id EQ type {: Logger.print("Type definition definition, id:" + id);:}
;

type ::=
	simple_type  {: Logger.print("Type definition - simple type");:}
	| structured_type {: Logger.print("Type definition - structured type");:}
	| pointer_type  {: Logger.print("Type definition - pointer type");:}
	| type_identifier {: Logger.print("Type definition - type identifier");:}
;

simple_type ::=
	subrange_type {: Logger.print("Simple type definition");:}
	| enumerated_type {: Logger.print("Simple type definition");:}
; 

subrange_type ::=
	lower_bound DOT_DOT upper_bound {: Logger.print("Subrange type definition");:}
;

lower_bound ::=
	constant {: Logger.print("Lower bound definition");:}
;

upper_bound ::=
	constant {: Logger.print("Upper bound definition");:}
;

enumerated_type ::=
	LPAREN identifier_list RPAREN {: Logger.print("Enumerated type definition");:}
;

structured_type ::=
	PACKED unpacked_structured_type {: Logger.print("Structured type definition");:}
	| unpacked_structured_type {: Logger.print("Structured type definition");:}
; 

unpacked_structured_type ::=
	array_type {: Logger.print("Unpacked structured type definition");:}
	| record_type {: Logger.print("Unpacked structured type definition");:}
	| set_type {: Logger.print("Unpacked structured type definition");:}
	| file_type {: Logger.print("Unpacked structured type definition");:}
;

array_type ::=
	ARRAY LBRACK index_type index_type_ext RBRACK OF element_type {: Logger.print("Array type definition");:}
;

index_type_ext ::=
	|
	COMMA index_type index_type_ext {: Logger.print("Index type extended definition");:}
;

index_type ::=
	simple_type {: Logger.print("Index type definition");:}
;

element_type ::=
	type {: Logger.print("Element type definition");:}
;

record_type ::=
	RECORD field_list END {: Logger.print("Record type definition");:}
;

field_list ::=
	fixed_part variant_part_opt {: Logger.print("Field list definition");:}
	| variant_part {: Logger.print("Field list definition");:}
	|
;

fixed_part ::=
	record_section record_section_ext {: Logger.print("Fixed part definition");:}
;

record_section_ext ::=
	|
	SEMICOLON record_section record_section_ext {: Logger.print("Record section extended definition");:}
;

record_section ::=
	identifier_list:il COLON type:t {: Logger.print("Record section definition, type: " + t + " identifier list :" + il);:}
;

variant_part_opt ::=
	|
	SEMICOLON variant_part {: Logger.print("Variant part optional definition");:}
;

variant_part ::=
	CASE tag_field IDENTIFIER OF variant variant_ext {: Logger.print("Variant part definition");:}
;

tag_field ::=
	|
	IDENTIFIER COLON {: Logger.print("Tag field definition");:}
;


variant_ext ::=
	|
	SEMICOLON variant variant_ext  {: Logger.print("Variant extended definition");:}
;

variant ::= 
	case_label_list COLON LPAREN field_list RPAREN {: Logger.print("Variant definition");:}
;

case_label_list ::=
	constant constant_ext {: Logger.print("Case label list definition");:}
;

constant_ext ::=
	|
	COMMA constant constant_ext {: Logger.print("Constant extended definition");:}
;

set_type ::=
	SET OF base_type {: Logger.print("Set type definition");:}
; 

base_type ::=
	type {: Logger.print("Base type definition");:}
;

file_type ::=
	FILE OF file_component_type {: Logger.print("File type definition");:}
;

file_component_type ::=
	type {: Logger.print("File component type definition");:}
;

pointer_type ::=
	POINTER IDENTIFIER {: Logger.print("Pointer type definition");:}
; 

type_identifier ::=
	IDENTIFIER {: Logger.print("Type identifier definition");:}
;

variable_declaration_part_opt ::=
	|
	variable_declaration_part {: Logger.print("Variable declaration part optional definition");:}
;

variable_declaration_part ::=
	VAR variable_declaration SEMICOLON variable_declaration_part_ext {: Logger.print("Variable declaration part definition");:}
;

variable_declaration_part_ext ::=
	|
	variable_declaration SEMICOLON variable_declaration_part_ext {: Logger.print("Variable declaration part extended definition");:} 
;

variable_declaration ::=
	identifier_list COLON type
;

procedure_and_function_declaration_part_opt ::=
	| 
	procedure_and_function_declaration_part
;

procedure_and_function_declaration_part ::=
	procedure_declaration SEMICOLON
	| function_declaration SEMICOLON
	| procedure_declaration SEMICOLON function_declaration SEMICOLON 
;

procedure_declaration ::=
	procedure_heading SEMICOLON procedure_body 
	| procedure_heading SEMICOLON directive 
	| procedure_identification SEMICOLON procedure_body
;

procedure_heading ::=
	PROCEDURE IDENTIFIER formal_parameter_list_opt 
;

formal_parameter_list_opt ::=
	|
	formal_parameter_list
;

formal_parameter_list ::=
	LPAREN formal_parameter_section formal_parameter_section_ext RPAREN
;

formal_parameter_section_ext ::=
	 |
	 SEMICOLON formal_parameter_section formal_parameter_section_ext 
;

formal_parameter_section ::=
	value_parameter_section 
	| variable_parameter_section 
	| procedure_parameter_section 
	| function_parameter_section
;

value_parameter_section ::=
	identifier_list COLON parameter_type
;

parameter_type ::=
	type_identifier 
	| conformant_array_schema
;

conformant_array_schema ::=
	packed_conformant_array_schema 
	| unpacked_conformant_array_schema
;

packed_conformant_array_schema ::=
	PACKED ARRAY LBRACK bound_specification RBRACK OF type_identifier
; 

bound_specification_ext ::=
	|
	SEMICOLON bound_specification bound_specification_ext 
;

bound_specification ::=
	IDENTIFIER DOT_DOT IDENTIFIER COLON ordinal_type_identifier
;

ordinal_type_identifier ::=
	type_identifier
;

unpacked_conformant_array_schema ::=
	/*ARRAY LBRACK bound_specification bound_specification_ext RBRACK OF type_identifier
	| ARRAY LBRACK bound_specification bound_specification_ext RBRACK OF conformant_array_schema*/
;

variable_parameter_section ::=

; 

procedure_parameter_section ::=

; 

function_parameter_section ::=

;

procedure_body ::=

;

directive ::=

;

procedure_identification ::=

;

function_declaration ::=

;

statement_part ::= 
	BEGIN statement_sequence END

;

statement ::= 
	variable_declaration:vd {: Logger.print("Line 218 "); RESULT = vd;:}
	| expression:e SEMICOLON {: Logger.print("Line 219 "+e);RESULT = e;:}
	| if_statement:ist {: Logger.print("Line 221");RESULT = ist;:}
	| while_statement:wstm {: Logger.print("Line 223");RESULT = wstm;:}
	| for_statement {: Logger.print("Line 224");:}
;

statement_sequence ::=

;

simple_statement ::=
	assignment_statement
	|procedure_statement
	|goto_statement

;

structured_statement ::=
	compound_statement 
	|repetitive_statement 
	|conditional_statement 
	|with_statement

;

assignment_statement ::=

;

procedure_sttatement ::=
	|procedure_identifier
	|actual_parameter_list 
;

goto_statement ::=
	GOTO label

;

compound_statement ::=
	BEGIN statement_sequence END

;

repetitive_statement ::=
	while_statement 
	|repeat_statement 
	|for_statement

;

conditional_statement ::=
	if_statement 
	|case_statement

;

while_statement ::=
	WHILE LPAREN expression RPAREN statement {: Logger.print("While statement");:}
;

repeat_statement ::=
	REPEAT statement_sequence UNTIL expression

;

for_statement ::=

;

initial_expression ::=
	expression

;

final_expression ::=
	expression
;

if_statement ::=
	IF LPAREN expression:exp RPAREN statement {: Logger.print("If statement");:}
	| IF LPAREN expression:exp RPAREN statement ELSE statement {: Logger.print("If statement");:}

;

expression ::=
;

case_statement ::=

;

case_limb ::= 

;

case_limb_list ::= 

;

actual_parameter_list ::= 

;

actual_parameter ::= 
	actual_value 
	|actual_variable 
	|actual_procedure 
	|actual_function
;

actual_value ::= 
	expression
;

actual_procedure ::= 
	procedure_identifier
;

actual_function ::= 
	function_identifier
;

actual_variable ::= 

;

record_variable ::= 

;

procedure_identifier ::= 

;

function_identifier ::= 

;

