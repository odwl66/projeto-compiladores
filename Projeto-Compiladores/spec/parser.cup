import compiler.util.*;

parser code  {:
 public void report_error(String message, Object info){
   StringBuffer m = new StringBuffer("Error: " + message + "\n");
   System.err.print(m);
 }

 public void report_fatal_error(String message, Object info) {
   report_error(message, info);
   throw new RuntimeException("Fatal Syntax Error");
 }
:};

terminal COMMA, SEMICOLON, COLON, DOT, DOT_DOT, LPAREN, RPAREN, LBRACK, RBRACK;
terminal EQ, SIGN;
terminal PROGRAM, CONST, LABEL, TYPE, PACKED, ARRAY, OF, RECORD, END, CASE;

terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING;
terminal java.lang.Number INTEGER_NUMBER;
terminal java.lang.Number REAL_NUMBER;

non terminal program;
non terminal program_heading, block;
non terminal identifier_list;
non terminal declaration_part, statement_part;
non terminal label, label_declaration_part, label_declaration_part_opt, label_declaration_part_ext;
non terminal constant_definition_part, constant_definition_part_opt, constant_definition_part_ext, constant_definition, constant;
non terminal type_definition_part, type_definition_part_opt, type_definition_part_ext, type_definition;
non terminal simple_type, structured_type, pointer_type, type_identifier, type;
non terminal subrange_type, enumerated_type;
non terminal unpacked_structured_type, array_type, record_type, set_type, file_type;
non terminal index_type, index_type_ext, element_type, field_list;
non terminal fixed_part, variant_part_opt, variant_part;
non terminal record_section, record_section_ext;
non terminal tag_field;
non terminal variant, variant_ext;
non terminal case_label_list;
non terminal constant_ext;
non terminal lower_bound, upper_bound;
non terminal variable_declaration_part, variable_declaration_part_opt;
non terminal procedure_and_function_declaration_part;
non terminal sign_opt;
non terminal number;

start with program;

program ::=
    program_heading block DOT {:Logger.print("Program definition");:}
;

program_heading ::=
    PROGRAM IDENTIFIER LPAREN identifier_list RPAREN SEMICOLON {:Logger.print("Program header definition");:}
;

identifier_list ::= 
	IDENTIFIER   {:Logger.print("Identifier list definition");:}
	| IDENTIFIER COMMA identifier_list {:Logger.print("Identifier list definition");:}
;

block ::= 
	declaration_part statement_part {: Logger.print("Block definition");:}
;

declaration_part ::=
	label_declaration_part_opt 
	constant_definition_part_opt
	type_definition_part_opt
	variable_declaration_part_opt
	procedure_and_function_declaration_part	{: Logger.print("Declaration part definition");:}
;

label_declaration_part_opt ::= 
	|
	label_declaration_part {: Logger.print("Label declaration part optional definition");:}
;

label_declaration_part ::=
	LABEL label label_declaration_part_ext SEMICOLON {: Logger.print("Label declaration part definition");:}
;

label_declaration_part_ext ::=
	|
	COMMA label label_declaration_part_ext  {: Logger.print("Label declaration part extended definition");:}
;

label ::=
	INTEGER_NUMBER:in {: Logger.print("Label definition: " + in);:}
;

constant_definition_part_opt  ::=
	|
	constant_definition_part {: Logger.print("Constant definition part optional definition");:}
;

constant_definition_part ::=
	CONST constant_definition SEMICOLON constant_definition_part_ext {: Logger.print("Constant definition part definition");:}
;

constant_definition_part_ext ::=
	|
	constant_definition SEMICOLON constant_definition_part_ext {: Logger.print("Constant definition part extended definition");:}
;

constant_definition ::=
	IDENTIFIER:id EQ constant:c {: Logger.print("Constant definition definition, id: " + id + " constant:" + c);:}
;

constant ::=
	sign_opt IDENTIFIER:id {: Logger.print("Constant definition, id: " + id);:}
	| number:n {: Logger.print("Constant definition, number: " + n);:}
	| STRING:s {: Logger.print("Constant definition, string: " + s);:}
;

sign_opt ::=
	SIGN
	|
;

number ::=
	INTEGER_NUMBER
	| REAL_NUMBER
;

type_definition_part_opt ::=
	|
	type_definition_part {: Logger.print("Type definition part definition");:}
;

type_definition_part ::=
	TYPE type_definition SEMICOLON type_definition_part_ext
;

type_definition_part_ext ::=
	|
	type_definition SEMICOLON type_definition_part_ext
;

type_definition ::=
	IDENTIFIER EQ type
;

type ::=
	simple_type 
	| structured_type 
	| pointer_type 
	| type_identifier
;

simple_type ::=
	subrange_type
	| enumerated_type
; 

subrange_type ::=
	lower_bound DOT_DOT upper_bound
;

lower_bound ::=
	constant
;

upper_bound ::=
	constant
;

enumerated_type ::=
	LPAREN identifier_list RPAREN
;

structured_type ::=
	PACKED unpacked_structured_type
	| unpacked_structured_type
; 

unpacked_structured_type ::=
	array_type
	| record_type
	| set_type 
	| file_type
;

array_type ::=
	ARRAY LBRACK index_type index_type_ext RBRACK OF element_type
;

index_type_ext ::=
	|
	COMMA index_type index_type_ext
;

index_type ::=
	simple_type
;

element_type ::=
	type
;
/*
record_type ::=
	RECORD field_list END
;

field_list ::=
	|
	| fixed_part variant_part_opt SEMICOLON 
	variant_part SEMICOLON
;

fixed_part ::=
	record_section record_section_ext
;

record_section_ext ::=
	|
	SEMICOLON record_section record_section_ext
;

record_section ::=
	identifier_list COLON type
;

variant_part_opt ::=
	|
	SEMICOLON variant_part
;

variant_part ::=
	CASE tag_field type_identifier OF variant variant_ext
;

tag_field ::=
	|
	IDENTIFIER COLON
;

type_identifier ::=
	IDENTIFIER
;

variant_ext ::=
	|
	SEMICOLON variant variant_ext 
;

variant ::= 
	case_label_list COLON LPAREN field_list RPAREN
;

case_label_list ::=
	constant constant_ext
;

constant_ext ::=
	| 
	COMMA constant constant_ext 
;
*/
set_type ::=

; 

file_type ::=

;

pointer_type ::=

; 

type_identifier ::=

;

variable_declaration_part_opt ::=
	|
	variable_declaration_part {: Logger.print("Variable declaration part optional definition");:}
;

variable_declaration_part ::=

;

procedure_and_function_declaration_part ::=

;

statement_part ::=

;
