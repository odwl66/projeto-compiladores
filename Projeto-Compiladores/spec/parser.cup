import compiler.util.*;

parser code  {:
 public void report_error(String message, Object info){
   StringBuffer m = new StringBuffer("Error: " + message + "\n");
   System.err.print(m);
 }

 public void report_fatal_error(String message, Object info) {
   report_error(message, info);
   throw new RuntimeException("Fatal Syntax Error");
 }
:};

terminal COMMA, SEMICOLON, COLON, DOT, DOT_DOT, LPAREN, RPAREN, LBRACK, RBRACK, POINTER;
terminal EQ, SIGN, ASSIGNMENT;
terminal PROGRAM, CONST, LABEL, TYPE, PACKED, ARRAY, OF, RECORD, BEGIN, END, CASE, SET, FILE, VAR, PROCEDURE, FUNCTION, FORWARD;
terminal IF, ELSE, DO, WHILE, FOR, BREAK, CONTINUE, RETURN, GOTO, UNTIL, REPEAT, TO, DOWNTO, WITH, THEN;

terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING;
terminal java.lang.Number INTEGER_NUMBER;
terminal java.lang.Number REAL_NUMBER;

non terminal program;
non terminal program_heading, program_heading_opt, block;
non terminal identifier_list;
non terminal declaration_part, statement_part, statement_sequence, simple_statement, structured_statement, simple_statement_aux, assignment_statement_aux;
non terminal statement, statement_block, assignment_statement, procedure_statement, goto_statement, aux_statement_sequence, statement_aux;
non terminal expression, expression_opt, expression_end_option, expression_loop;
non terminal while_statement, repeat_statement, for_statement, initial_expression, final_expression;
non terminal if_statement, case_statement, case_limb;
non terminal actual_parameter_list, actual_parameter, actual_value, actual_procedure, actual_function;
non terminal actual_variable, record_variable, procedure_identifier, function_identifier;
non terminal compound_statement, repetitive_statement, conditional_statement, with_statement;
non terminal label, label_declaration_part, label_declaration_part_opt, label_declaration_part_ext, optional_label;
non terminal constant_definition_part, constant_definition_part_opt, constant_definition_part_ext, constant_definition, constant;
non terminal simple_type, structured_type, pointer_type, type_identifier, type;
non terminal type_definition_part, type_definition_part_opt, type_definition_part_ext, type_definition;
non terminal subrange_type, enumerated_type;
non terminal unpacked_structured_type, array_type, record_type, set_type, file_type;
non terminal index_type, index_type_ext, element_type, field_list;
non terminal fixed_part, variant_part_opt, variant_part;
non terminal record_section, record_section_ext;
non terminal tag_field;
non terminal variant, variant_ext;
non terminal case_label_list;
non terminal constant_ext;
non terminal for_div_1;
non terminal lower_bound, upper_bound;
non terminal variable_declaration_part, variable_declaration_part_opt, variable_declaration_part_ext, variable_declaration, variable_identifier, variable;
non terminal procedure_and_function_declaration_part, procedure_and_function_declaration_part_opt;
non terminal procedure_declaration, procedure_heading, procedure_body, directive, procedure_identification;
non terminal formal_parameter_list_opt, formal_parameter_list, formal_parameter_section, formal_parameter_section_ext;
non terminal value_parameter_section, variable_parameter_section, procedure_parameter_section, function_parameter_section;
non terminal parameter_type, conformant_array_schema, packed_conformant_array_schema, unpacked_conformant_array_schema;
non terminal bound_specification, bound_specification_ext, ordinal_type_identifier;
non terminal function_declaration, function_heading, function_body, result_type;
non terminal number;
non terminal base_type;
non terminal file_component_type;
non terminal compiler_defined_directives;
non terminal entire_variable, component_variable, referenced_variable;
non terminal field_identifier;
non terminal indexed_variable, field_designator, file_buffer;
non terminal array_variable, expression_list, expression_ext;
non terminal file_variable;

start with program;

program ::=
    program_heading block DOT {:Logger.print("Program definition");:}
;

program_heading ::=
    PROGRAM IDENTIFIER program_heading_opt SEMICOLON {:Logger.print("Program header definition");:}
;

program_heading_opt ::=
	|
	LPAREN identifier_list RPAREN {:Logger.print("Program header optional definition");:}
;

identifier_list ::= 
	IDENTIFIER COMMA identifier_list {:Logger.print("Identifier list definition");:}
	| IDENTIFIER:id   {:Logger.print("Identifier list definition, id: " + id);:}
;

block ::= 
	declaration_part statement_part {: Logger.print("Block definition");:}
;

declaration_part ::=
	label_declaration_part_opt 
	constant_definition_part_opt
	type_definition_part_opt
	variable_declaration_part_opt
	procedure_and_function_declaration_part_opt	{: Logger.print("Declaration part definition");:}
;

label_declaration_part_opt ::= 
	|
	label_declaration_part {: Logger.print("Label declaration part optional definition");:}
;

label_declaration_part ::=
	LABEL label label_declaration_part_ext SEMICOLON {: Logger.print("Label declaration part definition");:}
;

label_declaration_part_ext ::=
	|
	COMMA label label_declaration_part_ext  {: Logger.print("Label declaration part extended definition");:}
;

label ::=
	INTEGER_NUMBER:in {: Logger.print("Label definition: " + in);:}
;

constant_definition_part_opt  ::=
	|
	constant_definition_part {: Logger.print("Constant definition part optional definition");:}
;

constant_definition_part ::=
	CONST constant_definition SEMICOLON constant_definition_part_ext {: Logger.print("Constant definition part definition");:}
;

constant_definition_part_ext ::=
	|
	constant_definition SEMICOLON constant_definition_part_ext {: Logger.print("Constant definition part extended definition");:}
;

constant_definition ::=
	IDENTIFIER:id EQ constant:c {: Logger.print("Constant definition definition, id: " + id + " constant:" + c);:}
;

constant ::=
	IDENTIFIER:id {: Logger.print("Constant definition, id: " + id);:}
	| SIGN IDENTIFIER:id {: Logger.print("Constant definition, id: " + id);:}
	| number:n {: Logger.print("Constant definition, number: " + n);:}
	| STRING:s {: Logger.print("Constant definition, string: " + s);:}
;

number ::=
	INTEGER_NUMBER {: Logger.print("Number definition");:}
	| REAL_NUMBER {: Logger.print("Number definition");:}
;

type_definition_part_opt ::=
	|
	type_definition_part {: Logger.print("Type definition part optional definition");:}
;

type_definition_part ::=
	TYPE type_definition SEMICOLON type_definition_part_ext {: Logger.print("Type definition part definition");:}
;

type_definition_part_ext ::=
	|
	type_definition SEMICOLON type_definition_part_ext {: Logger.print("Type definition part extended definition");:}
;

type_definition ::=
	IDENTIFIER:id EQ type {: Logger.print("Type definition definition, id:" + id);:}
;

type ::=
	simple_type  {: Logger.print("Type definition - simple type");:}
	| structured_type {: Logger.print("Type definition - structured type");:}
	| pointer_type  {: Logger.print("Type definition - pointer type");:}
	| type_identifier {: Logger.print("Type definition - type identifier");:}
;

simple_type ::=
	subrange_type {: Logger.print("Simple type definition");:}
	| enumerated_type {: Logger.print("Simple type definition");:}
; 

subrange_type ::=
	lower_bound DOT_DOT upper_bound {: Logger.print("Subrange type definition");:}
;

lower_bound ::=
	constant {: Logger.print("Lower bound definition");:}
;

upper_bound ::=
	constant {: Logger.print("Upper bound definition");:}
;

enumerated_type ::=
	LPAREN identifier_list RPAREN {: Logger.print("Enumerated type definition");:}
;

structured_type ::=
	PACKED unpacked_structured_type {: Logger.print("Structured type definition");:}
	| unpacked_structured_type {: Logger.print("Structured type definition");:}
; 

unpacked_structured_type ::=
	array_type {: Logger.print("Unpacked structured type definition");:}
	| record_type {: Logger.print("Unpacked structured type definition");:}
	| set_type {: Logger.print("Unpacked structured type definition");:}
	| file_type {: Logger.print("Unpacked structured type definition");:}
;

array_type ::=
	ARRAY LBRACK index_type index_type_ext RBRACK OF element_type {: Logger.print("Array type definition");:}
;

index_type_ext ::=
	|
	COMMA index_type index_type_ext {: Logger.print("Index type extended definition");:}
;

index_type ::=
	simple_type {: Logger.print("Index type definition");:}
;

element_type ::=
	type {: Logger.print("Element type definition");:}
;

record_type ::=
	RECORD field_list END {: Logger.print("Record type definition");:}
;

field_list ::=
	fixed_part variant_part_opt {: Logger.print("Field list definition");:}
	| variant_part {: Logger.print("Field list definition");:}
	|
;

fixed_part ::=
	record_section record_section_ext {: Logger.print("Fixed part definition");:}
;

record_section_ext ::=
	|
	SEMICOLON record_section record_section_ext {: Logger.print("Record section extended definition");:}
;

record_section ::=
	identifier_list:il COLON type:t {: Logger.print("Record section definition, type: " + t + " identifier list :" + il);:}
;

variant_part_opt ::=
	|
	SEMICOLON variant_part {: Logger.print("Variant part optional definition");:}
;

variant_part ::=
	CASE tag_field IDENTIFIER OF variant variant_ext {: Logger.print("Variant part definition");:}
;

tag_field ::=
	|
	IDENTIFIER COLON {: Logger.print("Tag field definition");:}
;


variant_ext ::=
	|
	SEMICOLON variant variant_ext  {: Logger.print("Variant extended definition");:}
;

variant ::= 
	case_label_list COLON LPAREN field_list RPAREN {: Logger.print("Variant definition");:}
;

case_label_list ::=
	constant constant_ext {: Logger.print("Case label list definition");:}
;

constant_ext ::=
	|
	COMMA constant constant_ext {: Logger.print("Constant extended definition");:}
;

set_type ::=
	SET OF base_type {: Logger.print("Set type definition");:}
; 

base_type ::=
	type {: Logger.print("Base type definition");:}
;

file_type ::=
	FILE OF file_component_type {: Logger.print("File type definition");:}
;

file_component_type ::=
	type {: Logger.print("File component type definition");:}
;

pointer_type ::=
	POINTER IDENTIFIER {: Logger.print("Pointer type definition");:}
; 

type_identifier ::=
	IDENTIFIER {: Logger.print("Type identifier definition");:}
;

variable_declaration_part_opt ::=
	|
	variable_declaration_part {: Logger.print("Variable declaration part optional definition");:}
;

variable_declaration_part ::=
	VAR variable_declaration SEMICOLON variable_declaration_part_ext {: Logger.print("Variable declaration part definition");:}
;

variable_declaration_part_ext ::=
	|
	variable_declaration SEMICOLON variable_declaration_part_ext {: Logger.print("Variable declaration part extended definition");:} 
;

variable_declaration ::=
	identifier_list COLON type {: Logger.print("Variable declaration definition");:}
;

procedure_and_function_declaration_part_opt ::=
	| 
	procedure_and_function_declaration_part {: Logger.print("Procedure and function declaration part optional definition");:}
;

procedure_and_function_declaration_part ::=
	procedure_declaration SEMICOLON {: Logger.print("Procedure and function declaration part definition");:}
	| function_declaration SEMICOLON {: Logger.print("Procedure and function declaration part definition");:}
	| procedure_declaration SEMICOLON function_declaration SEMICOLON {: Logger.print("Procedure and function declaration part definition");:}
;

procedure_declaration ::=
	procedure_heading SEMICOLON procedure_body {: Logger.print("Procedure declaration definition");:} 
	| procedure_heading SEMICOLON directive {: Logger.print("Procedure declaration definition");:}
;

procedure_heading ::=
	PROCEDURE IDENTIFIER formal_parameter_list_opt {: Logger.print("Procedure heading definition");:}
;

formal_parameter_list_opt ::=
	|
	formal_parameter_list {: Logger.print("Formal parameter list optional definition");:}
;

formal_parameter_list ::=
	LPAREN formal_parameter_section formal_parameter_section_ext RPAREN {: Logger.print("Formal parameter list definition");:}
;

formal_parameter_section_ext ::=
	 |
	 SEMICOLON formal_parameter_section formal_parameter_section_ext {: Logger.print("Formal parameter section extended definition");:}
;

formal_parameter_section ::=
	value_parameter_section {: Logger.print("Formal parameter section definition");:} 
	| variable_parameter_section {: Logger.print("Formal parameter section definition");:} 
	| procedure_parameter_section {: Logger.print("Formal parameter section definition");:}
	| function_parameter_section {: Logger.print("Formal parameter section definition");:}
;

value_parameter_section ::=
	identifier_list COLON parameter_type {: Logger.print("Value parameter section definition");:}
;

parameter_type ::=
	type_identifier {: Logger.print("Parameter type definition");:}
	| conformant_array_schema {: Logger.print("Parameter type definition");:}
;

conformant_array_schema ::=
	packed_conformant_array_schema {: Logger.print("Conformant array schema definition");:}
	| unpacked_conformant_array_schema {: Logger.print("Conformant array schema definition");:}
;

packed_conformant_array_schema ::=
	PACKED ARRAY LBRACK bound_specification RBRACK OF type_identifier {: Logger.print("Packed conformant array schema definition");:}
; 

bound_specification_ext ::=
	|
	SEMICOLON bound_specification bound_specification_ext {: Logger.print("Bound specification extended definition");:} 
;

bound_specification ::=
	IDENTIFIER DOT_DOT IDENTIFIER COLON ordinal_type_identifier {: Logger.print("Bound specification definition");:}
;

ordinal_type_identifier ::=
	type_identifier {: Logger.print("Ordinal type identifier definition");:}
;

unpacked_conformant_array_schema ::=
	ARRAY LBRACK bound_specification bound_specification_ext RBRACK OF type_identifier {: Logger.print("Unpacked conformant array schema definition");:}
	| ARRAY LBRACK bound_specification bound_specification_ext RBRACK OF conformant_array_schema {: Logger.print("Unpacked conformant array schema definition");:}
;

variable_parameter_section ::=
	VAR identifier_list COLON parameter_type {: Logger.print("Variable parameter section definition");:}
; 

procedure_parameter_section ::=
	procedure_heading {: Logger.print("Procedure parameter section definition");:}
; 

function_parameter_section ::=
	function_heading {: Logger.print("Function parameter section definition");:}
;

function_heading ::=
	FUNCTION IDENTIFIER formal_parameter_list_opt COLON result_type {: Logger.print("Function heading definition");:}
;

result_type ::=
	type_identifier {: Logger.print("Result type definition");:}
;

procedure_body ::=
	block {: Logger.print("Procedure body definition");:}
;

directive ::=
	FORWARD {: Logger.print("Directive definition");:}
	| compiler_defined_directives {: Logger.print("Directive definition");:}
;

compiler_defined_directives ::=

;

procedure_identification ::=
	PROCEDURE procedure_identifier {: Logger.print("Procedure identification definition");:}
;

function_declaration ::=
	function_heading SEMICOLON function_body 
	| function_heading SEMICOLON directive
;

function_body ::=
	block
;

statement_part ::= 
	BEGIN statement_sequence END {:Logger.print("Statement Part");:} 

;

statement ::=
  {:Logger.print("Statement - line 1");:} optional_label statement_aux
;

statement_aux ::=
  {:Logger.print("Statement Aux - line 1");:} simple_statement |
  {:Logger.print("Statement Aux - line 2");:} structured_statement
;

statement_sequence ::=
  statement aux_statement_sequence {:Logger.print("Statement sequence");:}
;

aux_statement_sequence ::=
  {:Logger.print("Aux statement sequence - Vazio -> ");:} |
  {:Logger.print("Aux statement sequence - line 2 -> statement ; aux_statement_sequence");:}  SEMICOLON statement aux_statement_sequence
;

optional_label ::=
  {:Logger.print("Optional Label - Vazio");:} |
  {:Logger.print("Optional Label - line 2");:} label COLON
;

simple_statement ::=
  {:Logger.print("Simple Statement - Vazio");:} |
  {:Logger.print("Simple Statement - line 2");:} variable simple_statement_aux |
  {:Logger.print("Simple Statement - line 3");:} goto_statement
;

simple_statement_aux ::=
  {:Logger.print("Simple Statement Aux - procedure");:} procedure_statement |
  {:Logger.print("Simple Statement Aux - assignment");:} assignment_statement
;

variable ::=
	entire_variable 
	| component_variable 
	| referenced_variable
;

entire_variable ::=
	variable_identifier 
	| field_identifier
;

variable_identifier ::=
	IDENTIFIER
; 

field_identifier ::=
	IDENTIFIER
;

component_variable ::= 
	indexed_variable 
	| field_designator
	| file_buffer
;

indexed_variable ::=
	array_variable LBRACK expression_list RBRACK
;

array_variable ::=
	variable
;

expression_list ::=
	expression expression_ext
;

expression_ext ::=
	|
	COMMA expression expression_ext
;

field_designator ::=
	record_variable DOT field_identifier
;

file_buffer ::=
	file_variable POINTER
;

file_variable ::=
	variable
;
 
referenced_variable ::=

;

simple_statement_aux ::=
  {:Logger.print("Simple Statement Aux - assignment");:} assignment_statement
  {:Logger.print("Simple Statement Aux - procedure");:} procedure_statement |
;

assignment_statement ::=
  {:Logger.print("Assignment Statement");:} assignment_statement_aux ASSIGNMENT expression
;

assignment_statement_aux ::= 
	{:Logger.print("Assignment Statement Aux - Line 1");:} variable | 
	{:Logger.print("Assignment Statement Aux - Line 2");:} function_identifier
;	

structured_statement ::=
  {:Logger.print("Structured statement - line 1");:} compound_statement |
  {:Logger.print("Structured statement - line 2");:} repetitive_statement |
  {:Logger.print("Structured statement - line 3");:} conditional_statement |
  {:Logger.print("Structured statement - line 4");:} with_statement
;

procedure_statement ::=
  {:Logger.print("Procedure statement");:} actual_parameter_list
;

goto_statement ::=
  {:Logger.print("Go to statement");:} GOTO label
;

compound_statement ::=
  {:Logger.print("Compound statement");:} BEGIN statement_sequence END
;

repetitive_statement ::=
  {:Logger.print("Repetitive Statement - line 1");:} while_statement |
  {:Logger.print("Repetitive Statement - line 2");:} repeat_statement |
  {:Logger.print("Repetitive Statement - line 3");:} for_statement
;

conditional_statement ::=
	{:Logger.print("Conditional Statement - line 1");:} if_statement |
	{:Logger.print("Conditional Statement - line 2");:} case_statement
;

while_statement ::=
  {:Logger.print("While statement Part");:} WHILE expression DO statement
;

repeat_statement ::=
  {:Logger.print("Repeat statement");:} REPEAT statement_sequence UNTIL expression
;

for_statement ::=
  {:Logger.print("For Statement - line 1");:} FOR variable_identifier ASSIGNMENT initial_expression TO final_expression DO statement |
  {:Logger.print("For Statement - line 2");:} FOR variable_identifier ASSIGNMENT initial_expression DOWNTO final_expression DO statement
;

initial_expression ::=
	expression

;

final_expression ::=
	expression
;

expression ::=
	
;


if_statement ::=
	{:Logger.print("If Statement");:} IF LPAREN expression:exp THEN statement LBRACK statement ELSE statement RBRACK
;

case_statement ::=
	{:Logger.print("Case Statement");:} CASE expression OF
	case_limb { SEMICOLON case_limb } LBRACK SEMICOLON RBRACK
	END
;

case_limb ::= 
	case_label_list COLON statement
;

case_label_list ::= 
	constant { SEMICOLON constant }
;

actual_parameter_list ::= 
	LPAREN actual_parameter { SEMICOLON actual_parameter } RPAREN
;

actual_parameter ::= 
	actual_value 
	|actual_variable 
	|actual_procedure 
	|actual_function
;

actual_value ::= 
	expression
;

actual_procedure ::= 
	procedure_identifier
;

actual_function ::= 
	function_identifier
;

actual_variable ::= 
	variable_declaration:vd {: Logger.print("actual variable "); RESULT = vd;:}
;


record_variable ::= 
	variable:v {: Logger.print("Line 218 "); RESULT = v;:}
;

procedure_identifier ::= 
	IDENTIFIER
;

function_identifier ::= 

;

